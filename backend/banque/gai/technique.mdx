[Voir la documentation fonctionnelle](./fonctionnelle.mdx)

# Documentation Technique - Module IAM (Gestion des Identités et des Accès)

Ce document décrit l'architecture technique et les composants du module de Gestion des Identités et des Accès (IAM) de l'application ERP Banking.

## 1. Vue d'Ensemble de l'Architecture

Le module IAM est crucial pour la sécurité de l'application. Il repose sur Spring Security et l'authentification par jetons JWT (JSON Web Tokens).

L'architecture s'articule autour des composants suivants :

*   **Configuration de Sécurité (Spring Security) :** Définit la chaîne de filtres de sécurité, le gestionnaire d'authentification, l'encodeur de mots de passe, et les règles d'autorisation.
*   **Contrôleur d'Authentification :** Expose les endpoints pour l'enregistrement et la connexion des utilisateurs.
*   **Services :**
    *   `AuthService` : Gère la logique d'enregistrement des utilisateurs.
    *   `UserDetailsServiceImpl` : Implémente l'interface `UserDetailsService` de Spring Security pour charger les informations d'un utilisateur par son email.
*   **Utilitaires JWT :**
    *   `JwtTokenUtil` : Génère, valide et extrait les informations des jetons JWT.
    *   `JwtRequestFilter` : Filtre Spring Security qui intercepte les requêtes HTTP, vérifie la présence et la validité d'un jeton JWT, et configure le contexte de sécurité.
    *   `JwtAuthEntryPoint` : Gère les erreurs d'authentification (ex: jeton manquant ou invalide).
*   **Entités JPA :**
    *   `UserEntity` : Représente un utilisateur dans la base de données.
    *   `RoleEntity` : Représente un rôle (bien que l'implémentation actuelle dans `UserEntity` stocke les rôles comme une liste de chaînes de caractères).
*   **DTOs :** Objets de transfert de données pour les requêtes et réponses API (enregistrement, connexion, réponse JWT).
*   **Référentiels (Repositories) :** Interfaces Spring Data JPA pour interagir avec les entités `UserEntity` et `RoleEntity`.

## 2. Composants Détaillés

### 2.1. Configuration de Sécurité (`com.cochepa.erp.banking.iam.config.SecurityConfig`)

<Card title="SecurityConfig">
  **Rôle :** Configure Spring Security pour l'application.
  
  **Annotations Clés :** `@Configuration`, `@EnableWebSecurity`, `@EnableMethodSecurity(prePostEnabled = true)`.
  
  **Beans Principaux :**
  <Callout type="info" title="passwordEncoder()">
    Fournit une instance de `BCryptPasswordEncoder` pour le hachage sécurisé des mots de passe.
  </Callout>
  <Callout type="info" title="authenticationManager(AuthenticationConfiguration)">
    Obtient le gestionnaire d'authentification de Spring Security.
  </Callout>
  <Callout type="info" title="filterChain(HttpSecurity http)">
    Configure la chaîne de filtres de sécurité HTTP :
    *   **CSRF Désactivé :** `csrf(AbstractHttpConfigurer::disable)` car l'authentification est basée sur des jetons.
    *   **Gestion des Exceptions :** `exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))` utilise `JwtAuthEntryPoint` pour les échecs d'authentification.
    *   **Gestion de Session :** `sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))` car les sessions sont sans état (stateless) avec JWT.
    *   **Autorisation des Requêtes :**
        *   `/api/v1/auth/**` : Permis à tous (pour login/register).
        *   `SWAGGER_UI_PATHS` : Permis à tous pour l'accès à la documentation Swagger UI.
        *   Ressources statiques communes et `/error` : Permis à tous.
        *   Toutes les autres requêtes (`anyRequest().authenticated()`) nécessitent une authentification.
    *   **Filtre JWT :** `http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class)` ajoute `JwtRequestFilter` avant le filtre d'authentification par nom d'utilisateur/mot de passe standard.
  </Callout>
</Card>

### 2.2. Contrôleur d'Authentification (`com.cochepa.erp.banking.iam.controller.AuthController`)

<Card title="AuthController">
  **Rôle :** Expose les endpoints REST pour l'enregistrement et la connexion.
  
  **Endpoints :**
  <Callout type="info" title="POST /api/v1/auth/login">
    *   Prend un `LoginRequestDto` (email, mot de passe).
    *   Utilise `AuthenticationManager` pour authentifier l'utilisateur.
    *   En cas de succès, charge `UserDetails` via `UserDetailsService` (implémenté par `UserDetailsServiceImpl`).
    *   Génère un jeton JWT via `JwtTokenUtil.generateToken()`.
    *   Récupère l'entité `UserEntity` complète pour obtenir l'ID utilisateur.
    *   Retourne un `JwtResponseDto` contenant le jeton, l'email, l'ID et les rôles.
    *   Gère `BadCredentialsException` (401) et autres exceptions (500).
  </Callout>
  <Callout type="info" title="POST /api/v1/auth/register">
    *   Prend un `RegisterRequestDto`.
    *   Appelle `AuthService.registerUser()` pour créer le nouvel utilisateur.
    *   Retourne un message de succès (201) ou une erreur (400 ou 500) si l'enregistrement échoue (ex: email déjà utilisé).
  </Callout>
</Card>

### 2.3. Services

<Card title="AuthService (`com.cochepa.erp.banking.iam.service.AuthService`)">
  **Rôle :** Gère la logique métier de l'enregistrement des utilisateurs.
  
  **Méthodes :**
  <Callout type="info" title="registerUser(RegisterRequestDto registerRequestDto)">
    *   Vérifie si l'email existe déjà (`userRepository.existsByEmail()`).
    *   Crée une nouvelle `UserEntity` avec les informations fournies.
    *   Encode le mot de passe (`passwordEncoder.encode()`).
    *   Assigne les rôles (par défaut "USER" si aucun n'est fourni dans la requête). L'implémentation actuelle stocke les rôles comme une `List<String>` dans `UserEntity`.
    *   Sauvegarde le nouvel utilisateur (`userRepository.save()`).
    *   Transactionnel (`@Transactional`).
  </Callout>
</Card>

<Card title="UserDetailsServiceImpl (`com.cochepa.erp.banking.iam.service.UserDetailsServiceImpl`)">
  **Rôle :** Implémente `UserDetailsService` de Spring Security.
  
  **Méthodes :**
  <Callout type="info" title="loadUserByUsername(String email)">
    *   Récupère `UserEntity` par email depuis `UserRepository`.
    *   Si non trouvé, lance `UsernameNotFoundException`.
    *   Convertit la liste des rôles (chaînes de caractères) de `UserEntity` en une collection de `GrantedAuthority` (en préfixant "ROLE_" et en mettant en majuscules, ex: "ROLE_USER").
    *   Retourne un objet `org.springframework.security.core.userdetails.User` contenant l'email, le hash du mot de passe, le statut d'activité et les autorités.
    *   Transactionnel en lecture seule (`@Transactional(readOnly = true)`).
  </Callout>
</Card>

### 2.4. Utilitaires et Filtres JWT

<Card title="JwtTokenUtil (`com.cochepa.erp.banking.iam.security.JwtTokenUtil`)">
  **Rôle :** Fournit des méthodes pour générer, valider et extraire des informations des jetons JWT.
  
  **Configuration :**
    *   `jwt.secret` : Clé secrète pour signer les jetons (doit être externalisée et sécurisée en production).
    *   `jwt.expirationMs` : Durée de validité des jetons.
  
  **Méthodes Clés :**
    *   `generateToken(UserDetails userDetails)` : Crée un jeton JWT avec l'email de l'utilisateur comme "subject".
    *   `validateToken(String token, UserDetails userDetails)` : Vérifie si le jeton est valide (non expiré et le nom d'utilisateur correspond).
    *   `getUsernameFromToken(String token)` : Extrait le nom d'utilisateur (subject) du jeton.
    *   `getExpirationDateFromToken(String token)` : Extrait la date d'expiration.
  <Callout type="note">
  Utilise la bibliothèque `io.jsonwebtoken` pour la manipulation des JWT. La clé est générée avec `Keys.hmacShaKeyFor()`.
  </Callout>
</Card>

<Card title="JwtRequestFilter (`com.cochepa.erp.banking.iam.security.JwtRequestFilter`)">
  **Rôle :** Filtre Spring Security qui s'exécute une fois par requête (`OncePerRequestFilter`).
  
  **Logique :**
  1.  Extrait le jeton JWT de l'en-tête `Authorization` (type "Bearer").
  2.  Si un jeton est trouvé, utilise `JwtTokenUtil` pour en extraire le nom d'utilisateur.
  3.  Si le nom d'utilisateur est obtenu et qu'il n'y a pas d'authentification existante dans le `SecurityContextHolder` :
      *   Charge `UserDetails` via `UserDetailsServiceImpl`.
      *   Valide le jeton avec `JwtTokenUtil.validateToken()`.
      *   Si valide, crée un `UsernamePasswordAuthenticationToken` et le place dans le `SecurityContextHolder`, marquant l'utilisateur comme authentifié pour cette requête.
  4.  Passe la requête au filtre suivant dans la chaîne.
  5.  Gère diverses exceptions JWT (expiré, malformé, signature invalide, etc.) en loguant des avertissements.
</Card>

<Card title="JwtAuthEntryPoint (`com.cochepa.erp.banking.iam.security.JwtAuthEntryPoint`)">
  **Rôle :** Implémente `AuthenticationEntryPoint` pour gérer les cas où un utilisateur non authentifié tente d'accéder à une ressource protégée.
  
  **Logique :**
    *   Est appelé lorsque `JwtRequestFilter` ne parvient pas à authentifier l'utilisateur ou si l'authentification est requise mais absente.
    *   Logue l'erreur et retourne une réponse HTTP 401 (Non autorisé) au format JSON, indiquant l'échec de l'authentification.
</Card>

### 2.5. Entités JPA

<Card title="UserEntity (`com.cochepa.erp.banking.iam.entity.UserEntity`)">
  **Table :** `users`
  
  **Champs Principaux :**
  | Champ           | Type                                      | Description / Contraintes                                     |
  |-----------------|-------------------------------------------|---------------------------------------------------------------|
  | `id`            | UUID, PK                                  | Identifiant unique.                                           |
  | `firstName`     | String                                    | Prénom.                                                       |
  | `lastName`      | String                                    | Nom de famille.                                               |
  | `email`         | String                                    | Email (unique, non nul).                                      |
  | `passwordHash`  | String                                    | Mot de passe haché (non nul).                                 |
  | `roles`         | List<String> (`columnDefinition="text[]"`) | Liste des noms de rôles (ex: "USER", "ADMIN").                |
  | `isActive`      | boolean                                   | Statut d'activité (non nul, défaut `true`).                   |
  | `createdByUser` | ManyToOne vers `UserEntity`               | Utilisateur créateur (audit JPA).                             |
  | `updatedByUser` | ManyToOne vers `UserEntity`               | Dernier utilisateur modificateur (audit JPA).                 |
  | `createdAt`     | OffsetDateTime                            | Date de création (audit JPA).                                 |
  | `updatedAt`     | OffsetDateTime                            | Date de dernière modification (audit JPA).                    |
  
  **Contraintes :** Unicité sur l'email.
</Card>

<Card title="RoleEntity (`com.cochepa.erp.banking.iam.entity.RoleEntity`)">
  **Table :** `roles`
  
  **Champs Principaux :**
  | Champ         | Type                                      | Description                                      |
  |---------------|-------------------------------------------|--------------------------------------------------|
  | `name`        | String, PK                                | Nom du rôle (unique, non nul, ex: "ADMIN").      |
  | `permissions` | List<String> (`columnDefinition="text[]"`) | Liste des permissions associées à ce rôle.       |
  | `description` | String                                    | Description du rôle.                             |
  
  <Callout type="note">
  Bien que `RoleEntity` existe, l'implémentation actuelle de `UserEntity` stocke les rôles comme une simple liste de chaînes de caractères (`List<String> roles`). Une relation `ManyToMany` entre `UserEntity` et `RoleEntity` serait une approche plus traditionnelle et flexible pour la gestion des rôles et permissions, mais n'est pas pleinement utilisée ici pour lier les utilisateurs aux rôles via une table de jointure. `UserDetailsServiceImpl` construit les `GrantedAuthority` à partir de la `List<String> roles` de `UserEntity`.
  </Callout>
</Card>

### 2.6. Référentiels (Repositories)

<Card title="UserRepository (`com.cochepa.erp.banking.iam.repository.UserRepository`)">
  **Interface :** `JpaRepository<UserEntity, UUID>`
  *   `findByEmail(String email)` : Récupère un utilisateur par son email.
  *   `existsByEmail(String email)` : Vérifie l'existence d'un utilisateur par email.
</Card>

<Card title="RoleRepository (`com.cochepa.erp.banking.iam.repository.RoleRepository`)">
  **Interface :** `JpaRepository<RoleEntity, String>`
  *   `findByName(String name)` : Récupère un rôle par son nom.
  <Callout type="note">
  Non activement utilisé par `AuthService` pour la validation des rôles lors de l'inscription dans la version actuelle.
  </Callout>
</Card>

## 3. Flux d'Authentification et d'Autorisation

### 3.1. Flux d'Authentification (Login)
<Card title="Flux : Authentification (Login)">
1.  L'utilisateur envoie ses identifiants (email, mot de passe) à `POST /api/v1/auth/login`.
2.  `AuthController` appelle `AuthenticationManager.authenticate()`.
    *   `AuthenticationManager` utilise `UserDetailsServiceImpl` pour charger l'utilisateur par email.
    *   Il compare le mot de passe fourni avec le hash stocké en utilisant `PasswordEncoder`.
3.  Si l'authentification réussit, `AuthController` génère un jeton JWT via `JwtTokenUtil`.
4.  Le jeton JWT est retourné au client dans un `JwtResponseDto`.
</Card>

### 3.2. Accès aux Ressources Protégées
<Card title="Flux : Accès aux Ressources Protégées">
1.  Le client envoie une requête à un endpoint protégé, en incluant le jeton JWT dans l'en-tête `Authorization: Bearer <token>`.
2.  `JwtRequestFilter` intercepte la requête.
    *   Valide le jeton JWT (signature, expiration, utilisateur).
    *   Si valide, crée un `UsernamePasswordAuthenticationToken` et le place dans `SecurityContextHolder`.
3.  Spring Security utilise les informations du `SecurityContextHolder` pour les vérifications d'autorisation.
    *   Les annotations `@PreAuthorize` sur les méthodes des contrôleurs (ou la configuration dans `SecurityConfig`) sont évaluées. Par exemple, `@PreAuthorize("hasRole('ADMIN')")` vérifie si l'utilisateur authentifié a le rôle "ADMIN". Les rôles sont dérivés des `GrantedAuthority` construites par `UserDetailsServiceImpl`.
4.  Si l'utilisateur est autorisé, la requête est traitée. Sinon, `JwtAuthEntryPoint` (pour les problèmes d'authentification) ou un `AccessDeniedHandler` (pour les problèmes d'autorisation, non explicitement configuré ici mais géré par défaut par Spring Security) retourne une erreur appropriée (401 ou 403).
</Card>

## 4. Points Clés de Sécurité
<Callout type="warning" title="Points Clés de Sécurité">
*   **Hachage des Mots de Passe :** `BCryptPasswordEncoder` est utilisé, ce qui est une bonne pratique.
*   **Jetons JWT Stateless :** Évite la gestion de session côté serveur, améliorant la scalabilité.
*   **HTTPS :** Crucial en production pour protéger les jetons JWT en transit (non configurable ici mais une exigence d'infrastructure).
*   **Secret JWT Sécurisé :** La clé secrète JWT (`jwt.secret`) doit être forte, unique par environnement, et stockée de manière sécurisée (pas codée en dur en production).
*   **Validation des Entrées :** Les DTOs utilisent des annotations de validation.
*   **Protection contre CSRF :** Désactivée car non pertinente pour une API stateless basée sur des jetons, mais il faut s'assurer que les clients ne sont pas vulnérables si l'API est appelée depuis des navigateurs sans protection adéquate.
*   **Gestion des Rôles :** L'implémentation actuelle des rôles dans `UserEntity` (liste de chaînes) est simple. Une gestion plus fine des permissions pourrait nécessiter une modélisation plus complexe avec `RoleEntity` et une table de jointure pour les permissions.
</Callout>

Cette documentation technique fournit une compréhension du fonctionnement interne du module IAM.
